// TODO: Fix responsiveness.
// TODO: Better solution for offset.


/**
 * Multirange slider
 * Credits: Lea Verou
 * https://leaverou.github.io/multirange/
 */
(function() {
    "use strict";
  
    var supportsMultiple = self.HTMLInputElement && "valueLow" in HTMLInputElement.prototype,
    descriptor = Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, "value"),
    siblings, sibling, k, output, ghostOutput;
  
    self.multirange = function(input) {
      if (supportsMultiple || input.classList.contains("multirange")) {
        return;
      }
  
      var values = input.getAttribute("value").split(",");
      var min = +input.min || 0;
      var max = +input.max || 100;
      var ghost = input.cloneNode();
  
      input.classList.add("multirange", "original");
      ghost.classList.add("multirange", "ghost");
  
      input.value = values[0] || min + (max - min) / 2;
      ghost.value = values[1] || min + (max - min) / 2;
  
      input.parentNode.insertBefore(ghost, input.nextSibling);
      
      // Add ghost output
      siblings = input.parentNode.childNodes;
      for (var i = 0; i < siblings.length; i++) {
        sibling = siblings[i];
        if (sibling.id == input.id) { k = true; }
        if ((k == true) && (sibling.nodeName == "OUTPUT")) {
          var output = sibling;
          var ghostOutput = sibling.cloneNode();
          ghostOutput.classList.add("multioutput","ghost");
          output.classList.add("multioutput","original");
        }
      }
      
      if(ghostOutput) {
       input.parentNode.insertBefore(ghostOutput, output.nextSibling);
     }
  
  
     Object.defineProperty(input, "originalValue", descriptor.get ? descriptor : {
        // Fuck you Safari >:(
        get: function() { return this.value; },
        set: function(v) { this.value = v; }
      });
  
     Object.defineProperties(input, {
      valueLow: {
        get: function() { return Math.min(this.originalValue, ghost.value); },
        set: function(v) { this.originalValue = v; },
        enumerable: true
      },
      valueHigh: {
        get: function() { return Math.max(this.originalValue, ghost.value); },
        set: function(v) { ghost.value = v; },
        enumerable: true
      }
    });
  
     if (descriptor.get) {
        // Again, fuck you Safari
        Object.defineProperty(input, "value", {
          get: function() { return this.valueLow + "," + this.valueHigh; },
          set: function(v) {
            var values = v.split(",");
            this.valueLow = values[0];
            this.valueHigh = values[1];
          },
          enumerable: true
        });
      }
  
      function update() {
        ghost.style.setProperty("--low", 100 * ((input.valueLow - min) / (max - min)) + 1 + "%");
        ghost.style.setProperty("--high", 100 * ((input.valueHigh - min) / (max - min)) - 1 + "%");
      }
  
      input.addEventListener("input", update);
      ghost.addEventListener("input", update);
  
      update();
    }
  
    multirange.init = function() {
      Array.from(document.querySelectorAll("input[type=range][multiple]:not(.multirange)")).forEach(multirange);
      modifyInputs();
    }
  
    if (document.readyState == "loading") {
      document.addEventListener("DOMContentLoaded", multirange.init);
      modifyInputs();
    }
    else {
      multirange.init();
      modifyInputs();
    }
  
  })();
  
  /**
   * Value Bubbles for Range Inputs
   * Credits: Chris Coyier & Dave Olsen
   * https://css-tricks.com/value-bubbles-for-range-inputs/
   */
   function modifyOffset() {
    var el, newPoint, newPlace, offset, siblings, k, newValue, singleValue;
     
    // Measure width of range input
    width    = this.offsetWidth;
     
    // Check if single value or multiple value
    singleValue = /^\d+$/.test(this.value);
    
    // Set new value
    if(singleValue) {
      newValue = this.value;
    } else {
      newValue = this.value.split(",");
      newValue = newValue[0];
    }
     //Here is where we add in our per slider code.  
     var output = document.getElementsByClassName(this.name)

     var updateDiv = output[0].closest('div').childNodes[4]
     var min = parseInt(output[0].textContent)
     var max = parseInt(output[1].textContent)
     
     console.log(min)
     updateDiv.textContent = this.name.toUpperCase() + ': ' +  min + ' - ' + max + ' '
     var name = this.name
     posts
     .hide()
       .filter(function(){
       //find products between 35 and 50 calories
       var val = this.getAttribute('data-' + name)
       return val >= min && max >= val
     })
         .show()
    // Figure out placement percentage between left and right of input
    newPoint = (newValue - this.getAttribute("min")) / (this.getAttribute("max") - this.getAttribute("min"));
     
    // Janky value to get pointer to line up better
    offset   = -2.5;
     
    // Prevent bubble from going beyond left or right (unsupported browsers)
    if (newPoint < 0) { newPlace = 0;  }
    else if (newPoint > 1) { newPlace = width; }
    else { newPlace = width * newPoint + offset; offset -= newPoint;}
    
    siblings = this.parentNode.childNodes;
     
    for (var i = 0; i < siblings.length; i++) {
      sibling = siblings[i];
      
      if (sibling.id == this.id) { k = true; }
      
      if ((k == true) && (sibling.nodeName == "OUTPUT")) {
    
        if (this.classList.contains("original")) { 
          if (sibling.classList.contains("original")) {
            outputTag = sibling;
          }
        } 
        else if (this.classList.contains("ghost")) { 
          if (sibling.classList.contains("ghost")) {
            outputTag = sibling;
          }
        }
        else {
          outputTag = sibling;
        }
      }
    }
     
    // Move bubble
    outputTag.style.left       = newPlace + "px";
    outputTag.style.marginLeft = offset + "%";
    outputTag.innerHTML        = newValue;
  }
  
  function modifyInputs() {
    
    var inputs = document.getElementsByTagName("input");
    for (var i = 0; i < inputs.length; i++) {
      if (inputs[i].getAttribute("type") == "range") {
        inputs[i].oninput = modifyOffset;
  
        // the following taken from http://stackoverflow.com/questions/2856513/trigger-onchange-event-manually and modified to work with oninput instead
        if ("fireEvent" in inputs[i]) {
          inputs[i].fireEvent("oninput");
        } else {
          var evt = document.createEvent("HTMLEvents");
          evt.initEvent("input", false, true);
          inputs[i].dispatchEvent(evt);
        }
      }
    }
  }
  
  